import{_ as i,o as a,c as l,e}from"./app-5e6e879c.js";const d={},h=e('<h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h2><h3 id="链表" tabindex="-1"><a class="header-anchor" href="#链表" aria-hidden="true">#</a> 链表</h3><ol><li><p>合并两个有序链表</p></li><li><p>链表的分解</p></li><li><p>合并 k 个有序链表</p></li><li><p>寻找单链表的倒数第 k 个节点</p></li><li><p>寻找单链表的中点</p></li><li><p>判断单链表是否包含环并找出环起点</p></li><li><p>判断两个单链表是否相交并找出交点</p></li><li><p>翻转单链表</p></li><li><p>每k个一组翻转链表</p></li><li><p>回文链表</p><ul><li>全翻转</li><li>后序遍历， 递归</li><li>双指针找中点，然后翻转后面的</li></ul></li></ol><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h3><p>双指针:</p><ol><li>删除有序数组中的重复项</li><li>移除元素</li><li>移动零</li></ol><p>左右指针</p><ol><li>二分查找</li><li>两数之和II</li><li>翻转数组</li><li>最长回文子串</li></ol><p>前缀:</p><ol><li>区域和检索-数组不可变</li><li>二维区域的检索</li></ol><p>区间算法</p><ol><li>区间加法</li><li>航班预定统计</li><li>拼车</li></ol><p>二维数组：</p><ol><li>颠倒字符串中的单词</li><li>旋转矩阵</li><li>螺旋矩阵</li><li>螺旋矩阵II</li></ol><p>滑动窗口:</p><ol><li>无重复字符的最长子串</li><li>最小覆盖子串</li><li>字符串的排列</li></ol><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h3><h3 id="图" tabindex="-1"><a class="header-anchor" href="#图" aria-hidden="true">#</a> 图</h3><p>图的存储有两种:</p><ul><li>邻接表: 空间少</li><li>邻接矩阵:</li></ul><p>图的遍历:</p><ol><li>所有可能的路径</li></ol><h3 id="设计数据结构" tabindex="-1"><a class="header-anchor" href="#设计数据结构" aria-hidden="true">#</a> 设计数据结构</h3><h4 id="单调栈" tabindex="-1"><a class="header-anchor" href="#单调栈" aria-hidden="true">#</a> 单调栈</h4><p>例: 栈中维护最大值， push时 如果前面值小则pop,</p><ol><li>下一个更大元素</li><li>每日温度</li><li>下一个更大元素II</li></ol><h4 id="单调队列" tabindex="-1"><a class="header-anchor" href="#单调队列" aria-hidden="true">#</a> 单调队列</h4><p>例: 单调增队列, push时清除队列中小的指</p><ol><li>滑动窗口最大值</li></ol><h4 id="lru" tabindex="-1"><a class="header-anchor" href="#lru" aria-hidden="true">#</a> LRU</h4><p>淘汰很久没被使用的</p><p>双向链表+hash</p><p>双向链表的实现: 可以使用首尾 dummy 节点, 就可以不去判断是否为空</p><h4 id="lfu" tabindex="-1"><a class="header-anchor" href="#lfu" aria-hidden="true">#</a> LFU</h4><p>淘汰使用频率小的</p><h4 id="用栈实现队列" tabindex="-1"><a class="header-anchor" href="#用栈实现队列" aria-hidden="true">#</a> 用栈实现队列</h4><p>两个栈 一个负责进 一个负责出</p><h4 id="队列实现栈" tabindex="-1"><a class="header-anchor" href="#队列实现栈" aria-hidden="true">#</a> 队列实现栈</h4><p>暴力首尾循环</p><h2 id="dp" tabindex="-1"><a class="header-anchor" href="#dp" aria-hidden="true">#</a> dp</h2><p>子序 零钱</p><h3 id="base" tabindex="-1"><a class="header-anchor" href="#base" aria-hidden="true">#</a> base</h3><ol><li><p>斐波那契数</p></li><li><p>零钱兑换 dp[i] = Math.min(dp[i], dp[i - coin] + 1)</p></li><li><p>最长递增子序列 dp[i] = Math.max(dp[i], dp[j] + 1 )</p></li><li><p>最长回文子序列 dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j]) dp[i][j] = dp[i+1][j-1] + 2</p></li><li><p>最长公共子序列 dp[i][j] = dp[i - 1][j - 1] +1 dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])</p></li></ol><h2 id="dp-1" tabindex="-1"><a class="header-anchor" href="#dp-1" aria-hidden="true">#</a> dp</h2><h3 id="dp-2" tabindex="-1"><a class="header-anchor" href="#dp-2" aria-hidden="true">#</a> dp</h3><h3 id="回溯" tabindex="-1"><a class="header-anchor" href="#回溯" aria-hidden="true">#</a> 回溯</h3><ol><li>全排列 46</li><li>子集 78</li><li>组合 77</li></ol><h3 id="bfs-dfs" tabindex="-1"><a class="header-anchor" href="#bfs-dfs" aria-hidden="true">#</a> bfs dfs</h3><ol><li>二叉树最小深度 dfs&amp;dfs</li><li></li></ol><h3 id="二分" tabindex="-1"><a class="header-anchor" href="#二分" aria-hidden="true">#</a> 二分</h3><ol><li>二分查找</li><li>二分查找左右端点</li></ol><h3 id="滑动窗口" tabindex="-1"><a class="header-anchor" href="#滑动窗口" aria-hidden="true">#</a> 滑动窗口</h3><ol><li>最小覆盖子串 76 <ul><li>进行子串对比时, 采用hash-map进行数据存储</li></ul></li><li><h2 id="无重复字符的最长子串-3" tabindex="-1"><a class="header-anchor" href="#无重复字符的最长子串-3" aria-hidden="true">#</a> 无重复字符的最长子串 3</h2></li></ol><h2 id="特殊问题" tabindex="-1"><a class="header-anchor" href="#特殊问题" aria-hidden="true">#</a> 特殊问题</h2><ol><li>计数质数 <ul><li>素数筛选法: 一个大的数组包含所有，然后递归标识非质数</li></ul></li></ol><h2 id="典型题" tabindex="-1"><a class="header-anchor" href="#典型题" aria-hidden="true">#</a> 典型题</h2><ol><li>接雨水 <ul><li>双指针: 左右取max ，然后cur与max比较为result,</li><li>dp: 分别计算左右最大值， 然后用最大值进行比较 求出每部分能接到的雨水</li></ul></li></ol>',57),r=[h];function p(n,o){return a(),l("div",null,r)}const t=i(d,[["render",p],["__file","catalog.html.vue"]]);export{t as default};
