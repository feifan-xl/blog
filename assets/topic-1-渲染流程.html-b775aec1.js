import{_ as e,o as i,c as l,e as t}from"./app-5e6e879c.js";const r={},s=t('<h3 id="浏览器从输入网址到页面展示过程" tabindex="-1"><a class="header-anchor" href="#浏览器从输入网址到页面展示过程" aria-hidden="true">#</a> 浏览器从输入网址到页面展示过程</h3><p>主要分为以下步骤:</p><ol><li>URL 输入 -&gt; 合法性 —&gt; 缓存</li><li>DNS 解析 (多级缓存)</li><li>建立 TCP 连接</li><li>发送 HTTP/HTPPS 请求(TLS连接)</li><li>服务器响应请求</li><li>浏览器解析渲染页面</li><li>http 请求结束， 断开TCP链接</li></ol><h4 id="页面渲染流程" tabindex="-1"><a class="header-anchor" href="#页面渲染流程" aria-hidden="true">#</a> 页面渲染流程</h4><ol><li><p>拿个到文件 根编码方式 转换为对应的字符</p></li><li><p>自上而下解析文档, 遇到html标记,调用html解析器解析为对应token, 将token按词法解析, 构成有标签 层级 结构的 dom tree</p></li><li><p>遇到 style link标识， 调用 css 解析器处理css 构建 csstree</p></li><li><p>script 标签, 调用js解析器, 绑定事件 修改domtree csstree</p></li><li><p>合并 domtree csstree 为 render tree， 计算每个可见元素节点的样式</p></li><li><p>在 render tree 上运行布局以计算每个节点的几乎尺寸(回流) layout tree</p></li><li><p>分层处理(z-index 3d变换 页面滚动), 建立层叠上下文</p></li><li><p>绘制和光栅化, 将布局转换为实际的像素</p><ul><li>其中将特定的层(video canvas transform)直接交给gpu加速, 其他的层浏览器自己绘制</li></ul></li><li><p>合成: 将图层进行合并，并以正确的顺序绘制在屏幕还是那个</p></li><li><p>创建 dom tree</p></li><li><p>创建 cssom tree</p></li><li><p>生成 render tree</p></li><li><p>布局 layout tree</p></li><li><p>转换为图层</p></li><li><p>将图层转换为位图(GPU+浏览器)</p></li><li><p>合成位图并显示在页面上</p></li></ol><h3 id="阻塞解析和渲染" tabindex="-1"><a class="header-anchor" href="#阻塞解析和渲染" aria-hidden="true">#</a> 阻塞解析和渲染</h3><p>style 标签的样式 - 由html解析器异步解析 - 不阻塞浏览器渲染（可能会出现闪屏（解析一点，显示一点现象）； - 不阻塞DOM解析。</p><p>link css: - 由CSS解析器解析（同步解析）； - 阻塞浏览器渲染（可以利用这种阻塞避免闪屏); - 阻塞其后js语句的执行： - 原因：如果后面js的内容是获取元素的样式，例如宽高等属性,如果不等样式解析完毕，后面的js就获得了错误的信息,由于浏览器也不知道后续js的具体内容，所以只好等前面所有样式解析完毕，再执行js。例如：firefox在样式加载和解析过程，会禁止所有脚本。（webkit内核的浏览器只会在js尝试访问样式属性或者可能受到未加载的样式影响时才会禁止脚本。 - 不阻塞DOM的解析： - 原因：DOM解析和CSS解析是两个并行的线程。 js - 阻塞dom解析 - 阻塞页面渲染 - 阻塞后续js执行 - defer 不会阻塞dom解析 - async 异步加载， 加载好后阻塞解析</p>',8),p=[s];function a(o,c){return i(),l("div",null,p)}const n=e(r,[["render",a],["__file","topic-1-渲染流程.html.vue"]]);export{n as default};
