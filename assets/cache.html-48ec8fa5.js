import{_ as e,o as a,c as i,e as l}from"./app-5e6e879c.js";const n="/blog/assets/http-cache-e42290a3.png",c={},s=l(`<h2 id="active-cache" tabindex="-1"><a class="header-anchor" href="#active-cache" aria-hidden="true">#</a> active cache</h2><p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p><ul><li>cookie</li><li>sessionStorage</li><li>localStorage</li><li>indexedDB</li></ul><h3 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> cookie</h3><ul><li>value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</li><li>http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击</li><li>secure 只能在协议为 HTTPS 的请求中携带</li><li>same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</li></ul><h3 id="indexeddb" tabindex="-1"><a class="header-anchor" href="#indexeddb" aria-hidden="true">#</a> indexedDB</h3><p>浏览器提供的本地数据库， NOSQL 类型 特点:</p><ol><li>键值对存储</li><li>异步读取</li><li>支持事务(error, abort, complete) 只要有一步失败，整个事务就回滚到事务发生前</li><li>同源限制</li><li>存储空间大</li><li>支持二进制存储</li></ol><h4 id="操作流程" tabindex="-1"><a class="header-anchor" href="#操作流程" aria-hidden="true">#</a> 操作流程</h4><p>打开数据库 ， 返回 IDBRequest 对象</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">openDB</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> version<span class="token punctuation">)</span>
  <span class="token operator">-</span> onsuccess
  <span class="token operator">-</span> onerror
  <span class="token operator">-</span> onupgradeneeded

transaction<span class="token punctuation">.</span><span class="token function">objectStore</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点：</h4><ul><li>储存量理论上没有上限</li><li>所有操作都是异步的，相比 <code>LocalStorage</code> 同步操作性能更高，尤其是数据量较大时</li><li>原生支持储存<code>JS</code>的对象</li><li>是个正经的数据库，意味着数据库能干的事它都能干</li></ul><h2 id="file-cache" tabindex="-1"><a class="header-anchor" href="#file-cache" aria-hidden="true">#</a> file cache</h2><ol><li>service worker</li><li>memory cache</li><li>disk cache 跨站点的情况，相同地址的也会被缓存，不会再去请求数据</li><li>push cache</li><li>PWA</li></ol><h3 id="cache-policy" tabindex="-1"><a class="header-anchor" href="#cache-policy" aria-hidden="true">#</a> cache policy</h3><p>文件缓存策略如下:</p><p><img src="`+n+'" alt="图片"></p><p>小结:</p><p>强缓存 HTTP-Header: Expires 和 cache-control</p><ul><li>expires HTTP/1 ， value 为 时间</li><li>cache-control HTTP/1.1 ，可由多个指令组成 <ul><li>max-age= 30</li><li>no-catch 允许本地缓存，但需要先进行协商缓存</li><li>no-store 禁用缓存</li></ul></li></ul><p>协商缓存 HTTP-Header: Last-Modified 和 ETag</p><ul><li>Last-Modified 上次修改时间， 文件被打开也会变化</li><li>ETag 类似于文件指纹，</li></ul><p>etag生成:</p><ul><li>静态文件, 时间戳+文件大小的16进制</li><li>buffer字符串， 长度+对应的hash no-cache、no-store 的区别</li></ul><p>no-cache 和 no-store 这两个指令在请求和响应中都可以使用 no-store 是真正的不进行任何缓存，告知服务器和缓存服务器，我请求、响应的内容里有机密信息； 当 no-cache 在请求头中被使用时，表示强制使用协商缓存 当 no-cache 在响应头中被返回时，表示缓存服务器不能对资源进行缓存，客户端可以缓存资源，但每次使用缓存资源前都必须先向服务器确认其有效性</p><p>启发式缓存: 如果 Expires，Cache-Control: max-age，或 Cache-Control: s-maxage 都没有在响应头中出现，并且设置了Last-Modified时</p>',27),o=[s];function r(t,d){return a(),i("div",null,o)}const p=e(c,[["render",r],["__file","cache.html.vue"]]);export{p as default};
