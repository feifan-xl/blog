import{_ as l,o as i,c as e,e as a}from"./app-5e6e879c.js";const d={},o=a('<h2 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> vite</h2><ol><li>特点</li><li>核心原理</li><li>hmr</li><li>预构建</li><li>diff with webpack</li></ol><h3 id="vite-特点" tabindex="-1"><a class="header-anchor" href="#vite-特点" aria-hidden="true">#</a> vite 特点</h3><p>为开发提供极速响应的 前端构建工具</p><ol><li>快速的冷启动: no bundle + es build 进行预构建</li><li>即时的模块热更新: 基于 ESM 的 HMR， 同时利用浏览器缓存策略提升速度</li><li>真正的按需加载: 利用浏览器的 ESM 支持， 实现按需加载</li></ol><h3 id="核心原理" tabindex="-1"><a class="header-anchor" href="#核心原理" aria-hidden="true">#</a> 核心原理</h3><p>开发阶段: 本质是利用浏览器对 ESM 特性的支持. 启动一个服务器去进行所有内容的拦截，将相应的内容以 esm 格式返回浏览器 build阶段: 预定义的rollup</p><h3 id="hmr" tabindex="-1"><a class="header-anchor" href="#hmr" aria-hidden="true">#</a> HMR</h3><p>通过 serverPluginHmr plugin 为核心实现 本质是: 通过 websocket 创建浏览器和服务器的通信监听文件的改变</p><ul><li>文件被修改时, 通知客户端修改从新加载相应代码并更新</li></ul><p>具体流程:</p><ol><li>创建 websocke 服务端和 client 文件, 启动服务</li><li>通过 chokidar 监听文件变化</li><li>代码变更后,服务端推送信息到客户端</li><li>客户端根据推送的消息,对不同的data.type 执行不同的逻辑操作(vue-reload, style-update, full-reload 等)</li></ol><p>关于 chokidar</p><ul><li>node fs.watchfile 通过轮巡检测文件变化， 有延迟, 切只能监听一个文件</li><li>fs.watch 通过操作系统提供的文件更改通知机制, 修改一个文件时，可能触发多次写操作，触发多次回调</li><li>实现: <ul><li>对文件修改时间比对</li><li>校验md5</li><li>尝试100ms 延迟， 避开中间状态</li><li>对边界条件的处理，对软连接、权限等情况处理</li></ul></li></ul><h3 id="预构建" tabindex="-1"><a class="header-anchor" href="#预构建" aria-hidden="true">#</a> 预构建</h3><p>首次启动vite时,会进行预构建, 目的如下:</p><ol><li>commonjs 和 UMD 兼容性: 在开发阶段，vite开发服务器将所有代码都视为ESM, 因为必须先将模块类型进行转换</li><li>性能: 将具有需要内部模块的 ESM 依赖项转换为单个模块， 如 <code>import { debounce } from &#39;lodash-es&#39;</code></li></ol><blockquote><p>依赖预构建仅适用于开发模式，并使用 esbuild 将依赖项转换为 ES 模块。在生产构建中，将使用 @rollup/plugin-commonjs。</p></blockquote><p>tip: vite默认只对 node_module 文件夹下的 .js .cjs进行转换, 其他cjs需要手动声明</p><h3 id="diff-with-webpack" tabindex="-1"><a class="header-anchor" href="#diff-with-webpack" aria-hidden="true">#</a> diff with webpack</h3><ol><li>启动时间快: <ul><li>webpack 先编译时间长</li><li>vite 预编译 解析模块依赖 使用esbuild(go 快)</li></ul></li><li>hmr: <ul><li>webpack 需要编译， 编译后diff chunk 然后再进行</li><li>vite nobundle, 通知浏览器去重新加载变化的文件即可</li></ul></li></ol><h2 id="rollup" tabindex="-1"><a class="header-anchor" href="#rollup" aria-hidden="true">#</a> rollup</h2><p>模块打包器</p><ul><li>scope-hosting</li><li>一次输出多种格式</li><li>文档精简</li><li>不支持一些特定的高级功能， 构建大型应用尤其费时 <ul><li>代码拆分 热更新(plugin)</li><li>动态导入(v3支持cjs)</li></ul></li></ul><h3 id="esbuild" tabindex="-1"><a class="header-anchor" href="#esbuild" aria-hidden="true">#</a> esbuild</h3><ul><li>无代码分割 css处理</li></ul><ol><li>使用go编写</li><li>大量并行操作</li><li>代码没有依赖第三方库</li><li>高效的内存利用 (每个阶段的数据是可以继续使用的, 其他工具不可以)</li></ol>',27),r=[o];function h(t,c){return i(),e("div",null,r)}const s=l(d,[["render",h],["__file","vite_rollup.html.vue"]]);export{s as default};
