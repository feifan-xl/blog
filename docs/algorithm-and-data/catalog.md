
## 数据结构

### 链表

1. 合并两个有序链表
2. 链表的分解
3. 合并 k 个有序链表
4. 寻找单链表的倒数第 k 个节点
5. 寻找单链表的中点
6. 判断单链表是否包含环并找出环起点
7. 判断两个单链表是否相交并找出交点

1. 翻转单链表
2. 每k个一组翻转链表
3. 回文链表
    - 全翻转
    - 后序遍历， 递归
    - 双指针找中点，然后翻转后面的


### 数组

双指针:
1. 删除有序数组中的重复项
2. 移除元素
3. 移动零

左右指针
1. 二分查找
2. 两数之和II
3. 翻转数组
4. 最长回文子串


前缀:
1. 区域和检索-数组不可变
2. 二维区域的检索

区间算法
1. 区间加法
2. 航班预定统计
3. 拼车

二维数组：
1. 颠倒字符串中的单词
2. 旋转矩阵
3. 螺旋矩阵
4. 螺旋矩阵II


滑动窗口:
1. 无重复字符的最长子串
2. 最小覆盖子串
3. 字符串的排列




### 二叉树



### 图

图的存储有两种:
- 邻接表: 空间少
- 邻接矩阵: 

图的遍历:
1. 所有可能的路径



### 设计数据结构


#### 单调栈

例: 栈中维护最大值， push时 如果前面值小则pop, 

1. 下一个更大元素
2. 每日温度
3. 下一个更大元素II

#### 单调队列


例: 单调增队列, push时清除队列中小的指


1. 滑动窗口最大值 


#### LRU

淘汰很久没被使用的

双向链表+hash

双向链表的实现: 可以使用首尾 dummy 节点, 就可以不去判断是否为空

#### LFU

淘汰使用频率小的



#### 用栈实现队列

两个栈 一个负责进 一个负责出

#### 队列实现栈

暴力首尾循环



## dp

子序
零钱



### base

1. 斐波那契数
2. 零钱兑换
    dp[i] = Math.min(dp[i], dp[i - coin] + 1)
3. 最长递增子序列
    dp[i] = Math.max(dp[i], dp[j] + 1   )
4. 最长回文子序列
    dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j])
    dp[i][j] = dp[i+1][j-1] + 2

5. 最长公共子序列
    dp[i][j] = dp[i - 1][j - 1]  +1
    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])




## dp


### dp


### 回溯

1. 全排列 46
2. 子集 78
3. 组合 77



### bfs dfs

1. 二叉树最小深度 dfs&dfs
2. 


### 二分

1. 二分查找
2. 二分查找左右端点

### 滑动窗口

1. 最小覆盖子串 76 
    - 进行子串对比时, 采用hash-map进行数据存储
2. 无重复字符的最长子串 3
    - 

## 特殊问题

1. 计数质数 
    - 素数筛选法: 一个大的数组包含所有，然后递归标识非质数

## 典型题

1. 接雨水
    - 双指针: 左右取max ，然后cur与max比较为result, 
    - dp: 分别计算左右最大值， 然后用最大值进行比较 求出每部分能接到的雨水
